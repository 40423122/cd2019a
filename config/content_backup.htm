<h1>各組期末報告說明</h1>
<p>各組員必須在 W17 上課之前完成期末報告簡報影片上傳與連結, 並放入本網站之"專案口頭簡報"頁面.</p>
<p>各組必須在 W17 上課之前完成分組期末報告 pdf 檔案, 上傳至各分組的倉儲中, 並將連結提供至本網站之"專案報告書"頁面.</p>
<p>期末報告期間每週對各成員之評分依據下列要項:</p>
<ol>
<li>各組員在各分組網站中所呈現之任務執行內容, 並拍攝操作影音 mp4, 將影片標題署名"國立虎尾科技大學-機械設計工程系-協同產品設計實習 A - 學號及影片主題" 後上傳, 並將影片嵌入本網站各章節頁面中.</li>
<li>每組將提供組長本網站倉儲協同管理權, 專門處理各組員在各分支或 master 分支中的 pull requests, 各組員必須透過以 ag1, ag2 .... 命名之分支對本倉儲改版, 確定內容無誤後, 再設法由組長處理各 pull requests 之內容合併, Github Pages 將設為與 master 分支對應, 各組員之評分將依據各 pull requests 中所列出之學號與內容判定.</li>
<li>請各組員勿將影片檔、圖片檔案或各式檔案送至本倉儲, 影片檔案請上傳至 Youtube, 圖片檔案請送至各組倉儲網站, 各式檔案則請送至各組員 Google Drive 區, 並以嵌入 (iframe), 將影片放入本網站, 其餘圖片或檔案則透過 img 或 a 標註放入各相關頁面.</li>
</ol>
<h4>2a 分組倉儲</h4>
<p><a href="https://github.com/mdekmol/cd2019a-task1-2019cda_t1_g1">https://github.com/mdekmol/cd2019a-task1-2019cda_t1_g1</a> (<a href="https://mdekmol.github.io/cd2019a-task1-2019cda_t1_g1">2ag1</a>)<br/><br/><a href="https://github.com/mdekmol/cd2019a-task1-2019cda_t1_g2">https://github.com/mdekmol/cd2019a-task1-2019cda_t1_g2</a> (<a href="https://mdekmol.github.io/cd2019a-task1-2019cda_t1_g2/content">2ag2</a>)<br/><br/><a href="https://github.com/mdekmol/cd2019a-task1-2019cda_t1_g3_1">https://github.com/mdekmol/cd2019a-task1-2019cda_t1_g3_1</a> (<a href="https://mdekmol.github.io/cd2019a-task1-2019cda_t1_g3_1">2ag3</a>)<br/><br/><a href="https://github.com/mdekmol/cd2019a-task1-2019cda_t1_g4">https://github.com/mdekmol/cd2019a-task1-2019cda_t1_g4</a> (<a href="https://mdekmol.github.io/cd2019a-task1-2019cda_t1_g4">2ag4</a>)<br/><br/><a href="https://github.com/mdekmol/cd2019a-task1-2019cda_t1_g5">https://github.com/mdekmol/cd2019a-task1-2019cda_t1_g5</a> (<a href="https://mdekmol.github.io/cd2019a-task1-2019cda_t1_g5">2ag5</a>)<br/><br/><a href="https://github.com/mdekmol/cd2019a-task1-2019cda_t1_g6">https://github.com/mdekmol/cd2019a-task1-2019cda_t1_g6</a> (<a href="https://mdekmol.github.io/cd2019a-task1-2019cda_t1_g6">2ag6</a>)</p>
<h1>執行規劃</h1>
<h2>手足球系統模擬</h2>
<p>專案成果摘要</p>
<p>專案執行動機</p>
<p>相關文獻探討</p>
<p>專案執行成員</p>
<p>執行使用套件</p>
<p>專案執行過程規劃</p>
<p>專案執行內容</p>
<p>專案結論</p>
<h1>設計與繪圖</h1>
<h2>零組件尺寸分析</h2>
<p>手足球系統的零組件尺寸分析 (可行性分析)</p>
<h2>參數設計與繪圖</h2>
<p>手足球系統的零組件參數設計與繪圖 (零組件初步設計繪圖)</p>
<p>Onshape 零組件連結</p>
<p></p>
<p><img alt="" height="412" src="/images/chrome_ohXNjf6oAg.png" width="615"/></p>
<h2>細部設計與 BOM</h2>
<h4>手足球零件格式說明</h4>
<p>手足球零件格式說明</p>
<h4>零件 BOM</h4>
<p>手足球零組件材料表 (含零組件下載連結)</p>
<h4>零件尺寸圖</h4>
<p>零件尺寸圖</p>
<h4>零件部分組裝圖</h4>
<p>零件部分組裝圖</p>
<h4>3D 零組件爆炸圖</h4>
<p>3D 零組件爆炸圖</p>
<h1>V-rep 動態模擬</h1>
<p></p>
<h2>Ag3-送球機構設計與模擬</h2>
<h4>每周進度</h4>
<p>W11進度</p>
<p>本周進行人員分配工作，由<span>張育偉、洪明棋、林聖翰等三人所負責，在初步的討論下已有了各自的課題，由明棋負責送球軌道和球門下集球通道的設計及繪製，聖翰負責將球翻轉送上球檯的翻轉平台，而育偉則是Onshape的組裝以及V-rep的模擬，暫定將於三周內完成並將由其他成員完成程式的部分。</span></p>
<p>W12進度</p>
<p>本周的進度是把送球機構的雛型加強，明棋將球門的斜度與寬度還有出球口重新做調整，聖翰將翻轉平台配合軌道重新調整了尺寸以及修正槽內的平台角度，育偉配合兩道球門的出球口與兩個反轉平台進球口架設兩條軌道。</p>
<p>W13進度</p>
<p>本周進行由三人所繪製之零組件以及足球桌的組裝，組立上可以發現各組件上存在著許多配合上的誤差，從這裡可以看出組員之間的溝通並沒有妥善的說明清楚，這亦是協同設計上不可忽視的一點，其中軌道的部分修改最為多次，主要是因為與其連接的零組件定位方面須考慮非常多。</p>
<h4>討論</h4>
<p>w11討論</p>
<p>首先的問題是如何將球送上場地，一開始是以場地上方、下方以及兩側的位子出發去找出那個位置所對應的其合適的方法，場地上方是一開始就不去考慮的，在上方的話軌道會影響遊玩者的視線，而顯得有些礙眼；場地側面則是把手將其裝設的空間給佔據，受空間受限而改用其他位置來考慮，因此重點部分決定由下方來著手，下方有的問題該屬如何將場地諞面填平，想的方法千奇百怪甚至有點天馬行空，最終定案為由場地下方送球，在中心處挖洞設置一個翻轉的撥球平台。</p>
<p>w12討論</p>
<p>本周的問題'將所有設計出來的機構調整尺寸到最佳化，球門方面調整了斜面以及送球口的尺寸，以便後續球在模擬時不會卡住，軌道將雛型設計出來並搭配球門與撥球平台。為了方便製造，原本兩個球門進球後會從撥球平台不同側經由軌道送入裡面，經過討論我們最後重新設計讓球都經由同一側進入撥球平台的槽中。</p>
<p><strong> </strong></p>
<h2>系統功能展示</h2>
<p>手足球模擬系統功能展示 (模擬展示與說明影片)</p>
<h3>Ag3-足球台模擬進度</h3>
<h4>0506模擬測試</h4>
<p>40623105</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/QPWfPGLW2BE" width="560"></iframe></p>
<p></p>
<p>40623109</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/JC-1Szy-1PI" width="560"></iframe></p>
<p>40623118</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/2ZhJYcfZ7ms" width="560"></iframe></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/InFd99SzftQ" width="560"></iframe></p>
<h4>0513<span>模擬測試</span></h4>
<p>40623105</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/hDOCdXlDlfs" width="560"></iframe></p>
<p>40623109</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/CCFIQs34HnI" width="560"></iframe></p>
<p>40623118</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/jLj4x16FeSg" width="560"></iframe></p>
<h4>0520<span>模擬測試</span></h4>
<p>40623105</p>
<p>尺寸限制</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/A3jjC_93hVw" width="560"></iframe></p>
<p>40623109</p>
<p><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="//www.youtube.com/embed/VtadsM_6xEs" width="560"></iframe></p>
<p>40623118</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/8K-59ISQux0" width="560"></iframe></p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/1jI4ycqSsnk" width="560"></iframe></p>
<h4>0522<span>模擬測試</span></h4>
<p>40623118</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/HLf9ddvARq8" width="560"></iframe></p>
<h4>0523<span>模擬測試</span></h4>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/xw30fQEnwRw" width="560"></iframe></p>
<h4>0525<span>模擬測試</span></h4>
<p><span>40623109</span></p>
<p><span><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="//www.youtube.com/embed/dJdOBtd_6_I" width="560"></iframe></span><span></span></p>
<p><span><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="//www.youtube.com/embed/GlUkklJDP4k" width="560"></iframe></span></p>
<p><span><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="//www.youtube.com/embed/_6-32SsqBfQ" width="560"></iframe></span></p><h3>Ag3-第十二週-影像辨識尋找球和桿子位置</h3>
<p>利用影像辨識系統尋找紅方、藍方和綠球的位置。</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/C947PvvFDiw" width="560"></iframe></p>
<p>程式利用<a href="https://github.com/nemilya/vrep-api-python-opencv">https://github.com/nemilya/vrep-api-python-opencv</a>改編而成</p>
<p>vrep設定檔:<a href="https://github.com/mdekmol/cd2019a-task1-2019cda_t1_g3_1/blob/master/v-rep/40623128/TableFootBall/v-rep/tablefootball%20-%200507.ttt">https://github.com/mdekmol/cd2019a-task1-2019cda_t1_g3_1/blob/master/v-rep/40623128/TableFootBall/v-rep/tablefootball - 0507.ttt</a></p>
<p>程式檔:<a href="https://github.com/mdekmol/cd2019a-task1-2019cda_t1_g3_1/blob/master/v-rep/40623128/TableFootBall/v-rep/Image_Detection_RGB.py">https://github.com/mdekmol/cd2019a-task1-2019cda_t1_g3_1/blob/master/v-rep/40623128/TableFootBall/v-rep/Image_Detection_RGB.py</a></p>
<p>程式碼:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import vrep
import time

from PIL import Image as I
import array

import cv2, numpy

# function based on: 
#   https://github.com/simondlevy/OpenCV-Python-Hacks/blob/master/greenball_tracker.py
def track_green_object(image):
    # Blur the image to reduce noise100
    blur = cv2.GaussianBlur(image, (5,5),0)
    # Convert BGR to HSV
    hsv = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)
    # Threshold the HSV image for only green colors
    range = 15
    lower_green = numpy.array([60-range,100,100])
    upper_green = numpy.array([60+range,255,255])
    # Threshold the HSV image to get only green colors
    mask = cv2.inRange(hsv, lower_green, upper_green)
    # Blur the mask
    bmask = cv2.GaussianBlur(mask, (5,5),0)
    # Take the moments to get the centroid
    moments = cv2.moments(bmask)
    m00 = moments['m00']
    centroid_x, centroid_y = None, None
    if m00 != 0:
        centroid_x = int(moments['m10']/m00)
        centroid_y = int(moments['m01']/m00)
    # Assume no centroid
    ctr = None
    # Use centroid if it exists
    if centroid_x != None and centroid_y != None:
        ctr = (centroid_x, centroid_y)
    return ctr

def track_blue_object(image):
    # Blur the image to reduce noise100
    blur = cv2.GaussianBlur(image, (5,5),0)
    # Convert BGR to HSV
    hsv = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)
    # Threshold the HSV image for only green colors
    range = 15
    lower_red = numpy.array([0-range,100,100])
    upper_red = numpy.array([0+range,255,255])
    # Threshold the HSV image to get only green colors
    mask = cv2.inRange(hsv, lower_red, upper_red)
    # Blur the mask
    bmask = cv2.GaussianBlur(mask, (5,5),0)
    # Take the moments to get the centroid
    moments = cv2.moments(bmask)
    m00 = moments['m00']
    centroid_x, centroid_y = None, None
    if m00 != 0:
        centroid_x = int(moments['m10']/m00)
        centroid_y = int(moments['m01']/m00)
    # Assume no centroid
    ctr = None
    # Use centroid if it exists
    if centroid_x != None and centroid_y != None:
        ctr = (centroid_x, centroid_y)
    return ctr
    
def track_red_object(image):
    # Blur the image to reduce noise100
    blur = cv2.GaussianBlur(image, (5,5),0)
    # Convert BGR to HSV
    hsv = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)
    # Threshold the HSV image for only green colors
    range = 15
    lower_blue = numpy.array([120-range,100,100])
    upper_blue = numpy.array([120+range,255,255])
    # Threshold the HSV image to get only green colors
    mask = cv2.inRange(hsv, lower_blue, upper_blue)
    # Blur the mask
    bmask = cv2.GaussianBlur(mask, (5,5),0)
    # Take the moments to get the centroid
    moments = cv2.moments(bmask)
    m00 = moments['m00']
    centroid_x, centroid_y = None, None
    if m00 != 0:
        centroid_x = int(moments['m10']/m00)
        centroid_y = int(moments['m01']/m00)
    # Assume no centroid
    ctr = None
    # Use centroid if it exists
    if centroid_x != None and centroid_y != None:
        ctr = (centroid_x, centroid_y)
    return ctr

vrep.simxFinish(-1)
clientID = vrep.simxStart('127.0.0.1', 19997, True, True, 5000, 5)

if clientID!=-1:
  print('Connected to remote API server')
  # get vision sensor objects
  res, v0 = vrep.simxGetObjectHandle(clientID, 'vs1', vrep.simx_opmode_oneshot_wait)
  res, v1 = vrep.simxGetObjectHandle(clientID, 'vs2', vrep.simx_opmode_oneshot_wait)
  err, resolution, image = vrep.simxGetVisionSensorImage(clientID, v0, 0, vrep.simx_opmode_streaming)
  time.sleep(1)
  while (vrep.simxGetConnectionId(clientID) != -1):
    # get image from vision sensor 'v0'
    err, resolution, image = vrep.simxGetVisionSensorImage(clientID, v0, 0, vrep.simx_opmode_buffer)
    if err == vrep.simx_return_ok:
        image_byte_array = array.array('b', image)
        #print(image_byte_array)
        image_buffer = I.frombuffer("RGB", (resolution[0],resolution[1]), bytes(image_byte_array), "raw", "RGB", 0, 1)
        img2 = numpy.asarray(image_buffer)
      # try to find something green
        ret_green = track_green_object(img2)
        ret_red = track_red_object(img2)
        ret_blue = track_blue_object(img2)
      # overlay rectangle marker if something is found by OpenCV
        if ret_green:
            cv2.rectangle(img2,(ret_green[0]-5,ret_green[1]-5), (ret_green[0]+5,ret_green[1]+5), (0x99,0xff,0x33), 1)
          # return image to sensor 'v1'
        if ret_red:
            cv2.rectangle(img2,(ret_red[0]-3,ret_red[1]-5), (ret_red[0]+3,ret_red[1]+5), (0xff,0x33,0x33), 1)
        if ret_blue:
            cv2.rectangle(img2,(ret_blue[0]-3,ret_blue[1]-5), (ret_blue[0]+3,ret_blue[1]+5), (0x33,0xcc,0xff), 1)
        img2 = img2.ravel()
        #print('B=',ret_blue[0],ret_blue[1])
        #print('R=',ret_red[0],ret_red[1])
        #print('G=',ret_green[0],ret_green[1])
        vrep.simxSetVisionSensorImage(clientID, v1, img2, 0, vrep.simx_opmode_oneshot)
    elif err == vrep.simx_return_novalue_flag:
      print("no image yet")
      pass
    else:
      print(err)
else:
  print("Failed to connect to remote API Server")
  vrep.simxFinish(clientID)</pre>
<h3>Ag3-第十三週-影像辨識機器對打</h3>
<p>利用影像辨識抓取球與操作桿位置並使之對打，</p>
<p>由於影像需要處理時間，所以模擬速度越快抓取位置越不精確。</p>
<p>已知錯誤:</p>
<p>如果球打到桿子後方會無法回擊。</p>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/Nv5ppem_j_8" width="560"></iframe></p>
<p>vrep設定檔:<a href="https://github.com/mdekmol/cd2019a-task1-2019cda_t1_g3_1/blob/master/v-rep/40623128/TableFootBall/v-rep/tablefootball%20-%200507.ttt">tablefootball - 0507.ttt</a></p>
<p>程式檔:<a href="https://github.com/mdekmol/cd2019a-task1-2019cda_t1_g3_1/blob/master/v-rep/40623128/TableFootBall/v-rep/Image_Detection_play.py">Image_Detection_play.py</a></p>
<p>程式碼:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import vrep
import time

from PIL import Image as I
import array

import cv2, numpy

# function based on: 
#   https://github.com/simondlevy/OpenCV-Python-Hacks/blob/master/greenball_tracker.py
def speed(handle,speed):
    vrep.simxSetJointTargetVelocity(clientID,handle,speed,vrep.simx_opmode_oneshot_wait)
def track_green_object(image):
    # Blur the image to reduce noise100
    blur = cv2.GaussianBlur(image, (5,5),0)
    # Convert BGR to HSV
    hsv = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)
    # Threshold the HSV image for only green colors
    range = 15
    lower_green = numpy.array([60-range,100,100])
    upper_green = numpy.array([60+range,255,255])
    # Threshold the HSV image to get only green colors
    mask = cv2.inRange(hsv, lower_green, upper_green)
    # Blur the mask
    bmask = cv2.GaussianBlur(mask, (5,5),0)
    # Take the moments to get the centroid
    moments = cv2.moments(bmask)
    m00 = moments['m00']
    centroid_x, centroid_y = None, None
    if m00 != 0:
        centroid_x = int(moments['m10']/m00)
        centroid_y = int(moments['m01']/m00)
    # Assume no centroid
    ctr = None
    # Use centroid if it exists
    if centroid_x != None and centroid_y != None:
        ctr = (centroid_x, centroid_y)
    return ctr

def track_blue_object(image):
    # Blur the image to reduce noise100
    blur = cv2.GaussianBlur(image, (5,5),0)
    # Convert BGR to HSV
    hsv = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)
    # Threshold the HSV image for only green colors
    range = 15
    lower_red = numpy.array([0-range,100,100])
    upper_red = numpy.array([0+range,255,255])
    # Threshold the HSV image to get only green colors
    mask = cv2.inRange(hsv, lower_red, upper_red)
    # Blur the mask
    bmask = cv2.GaussianBlur(mask, (5,5),0)
    # Take the moments to get the centroid
    moments = cv2.moments(bmask)
    m00 = moments['m00']
    centroid_x, centroid_y = None, None
    if m00 != 0:
        centroid_x = int(moments['m10']/m00)
        centroid_y = int(moments['m01']/m00)
    # Assume no centroid
    ctr = None
    # Use centroid if it exists
    if centroid_x != None and centroid_y != None:
        ctr = (centroid_x, centroid_y)
    return ctr
    
def track_red_object(image):
    # Blur the image to reduce noise100
    blur = cv2.GaussianBlur(image, (5,5),0)
    # Convert BGR to HSV
    hsv = cv2.cvtColor(blur, cv2.COLOR_BGR2HSV)
    # Threshold the HSV image for only green colors
    range = 15
    lower_blue = numpy.array([120-range,100,100])
    upper_blue = numpy.array([120+range,255,255])
    # Threshold the HSV image to get only green colors
    mask = cv2.inRange(hsv, lower_blue, upper_blue)
    # Blur the mask
    bmask = cv2.GaussianBlur(mask, (5,5),0)
    # Take the moments to get the centroid
    moments = cv2.moments(bmask)
    m00 = moments['m00']
    centroid_x, centroid_y = None, None
    if m00 != 0:
        centroid_x = int(moments['m10']/m00)
        centroid_y = int(moments['m01']/m00)
    # Assume no centroid
    ctr = None
    # Use centroid if it exists
    if centroid_x != None and centroid_y != None:
        ctr = (centroid_x, centroid_y)
    return ctr

vrep.simxFinish(-1)
clientID = vrep.simxStart('127.0.0.1', 19997, True, True, 5000, 5)

if clientID!=-1:
  print('Connected to remote API server')
  # get vision sensor objects
  res, v0 = vrep.simxGetObjectHandle(clientID, 'vs1', vrep.simx_opmode_oneshot_wait)
  res, v1 = vrep.simxGetObjectHandle(clientID, 'vs2', vrep.simx_opmode_oneshot_wait)
  err, resolution, image = vrep.simxGetVisionSensorImage(clientID, v0, 0, vrep.simx_opmode_streaming)
  err,Sphere_handle=vrep.simxGetObjectHandle(clientID,'Sphere',vrep.simx_opmode_oneshot_wait)
  err,BRod_handle=vrep.simxGetObjectHandle(clientID,'BRod',vrep.simx_opmode_oneshot_wait)
  err,BRev_handle=vrep.simxGetObjectHandle(clientID,'BRev',vrep.simx_opmode_oneshot_wait)
  err,BMo_handle=vrep.simxGetObjectHandle(clientID,'BMo',vrep.simx_opmode_oneshot_wait)
  err,RRev_handle=vrep.simxGetObjectHandle(clientID,'RRev',vrep.simx_opmode_oneshot_wait)
  err,RMo_handle=vrep.simxGetObjectHandle(clientID,'RMo',vrep.simx_opmode_oneshot_wait)
  err,RRod_handle=vrep.simxGetObjectHandle(clientID,'RRod',vrep.simx_opmode_oneshot_wait)
  time.sleep(1)
  while (vrep.simxGetConnectionId(clientID) != -1):
    # get image from vision sensor 'v0'
    err, resolution, image = vrep.simxGetVisionSensorImage(clientID, v0, 0, vrep.simx_opmode_buffer)
    if err == vrep.simx_return_ok:
        image_byte_array = array.array('b', image)
        #print(image_byte_array)
        image_buffer = I.frombuffer("RGB", (resolution[0],resolution[1]), bytes(image_byte_array), "raw", "RGB", 0, 1)
        img2 = numpy.asarray(image_buffer)
      # try to find something green
        ret_green = track_green_object(img2)
        ret_red = track_red_object(img2)
        ret_blue = track_blue_object(img2)
        #print('B=',ret_blue[1],ret_blue[0])#y軸座標為0 x軸座標為1
        #print('R=',ret_red[1],ret_red[0])
        #print('G=',ret_green[1],ret_green[0])
        if ret_green != None and ret_red != None and ret_blue != None:
            Bv = float(ret_green[0])-float(ret_blue[0])
            BBv=float(ret_green[1])-float(ret_blue[1])
            Rv = float(ret_green[0])-float(ret_red[0])
            RRv=float(ret_green[1])-float(ret_red[1])
            if Bv&lt;0.0:
                speed(BMo_handle,Bv*-0.02)
            elif Bv&gt;0.0:
                speed(BMo_handle,Bv*-0.02)
            else:
                speed(BMo_handle,0)
            if Rv&lt;0.0:
                speed(RMo_handle,Rv*-0.02)
            elif Rv&gt;0.0:
                speed(RMo_handle,Rv*-0.02)
            else:
                speed(RMo_handle,0)
            if RRv&lt;-10.0:
                speed(RRev_handle,-2)
            elif RRv&gt;-10.0:
                speed(RRev_handle,2)
            else:
                pass
            if BBv&lt;10.0:
                speed(BRev_handle,-2)
            elif BBv&gt;10.0:
                speed(BRev_handle,2)
            else:
                pass
      # overlay rectangle marker if something is found by OpenCV
        if ret_green:
            cv2.rectangle(img2,(ret_green[0]-5,ret_green[1]-5), (ret_green[0]+5,ret_green[1]+5), (0x99,0xff,0x33), 1)
          # return image to sensor 'v1'
        if ret_red:
            cv2.rectangle(img2,(ret_red[0]-3,ret_red[1]-5), (ret_red[0]+3,ret_red[1]+5), (0xff,0x33,0x33), 1)
        if ret_blue:
            cv2.rectangle(img2,(ret_blue[0]-3,ret_blue[1]-5), (ret_blue[0]+3,ret_blue[1]+5), (0x33,0xcc,0xff), 1)
        img2 = img2.ravel()
        vrep.simxSetVisionSensorImage(clientID, v1, img2, 0, vrep.simx_opmode_oneshot)
    elif err == vrep.simx_return_novalue_flag:
      print("no image yet")
      pass
    else:
      print(err)
else:
  print("Failed to connect to remote API Server")
  vrep.simxFinish(clientID)</pre>
<h1>結案報告</h1>
<h2>專案口頭簡報</h2>
<p>各組利用倉儲中的 Reveal.js 進行結案簡報 (結案口頭簡報)</p>
<h2>專案報告書</h2>
<p>各組完成 html 與 pdf 格式之手足球專案結案報告 (文字結案報告書)</p>